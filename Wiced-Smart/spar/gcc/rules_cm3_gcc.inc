################################################################################
# CM3 specific spar rules
################################################################################
#
# GCC make steps:
#
# Common
# 1) Build Source files - recipes in the bottom of spar/makefile
# 2) Build ELF file     - recipe $(ELF_OUT) in of spar/makefile
#                         (This also builds a symbol list file output $(ELF_OUT_LIST))
#
# Configs Target (cgs)
# 3) For each section in $(UNCOMPRESSED_SECTIONS) and $(COMPRESSED)
#        -  use section_to_cgs script to extract the bytes in cgs format, compressing it or overlaying it based on how the section needs to be handled.
#              recipe $(ELF_OUT)%.cgs (regular section) or $(ELF_OUT)%.ccgs (compressed section) or $(ELF_OUT)%.ocgs (overlaid section)
# 4) Use the setup_call_cgs script to create a config for the entry point - file extension .elf.spar_setup_call.cgs (recipe $(SPAR_SETUP_CALL_CGS) in this file)
# 5) Concatenate all the config files together into the output config (recipe $(SPAR_CGS_TARGET) in spar/makefile)
# 6) Print statistics (recipe print_stats in this file)
#
#
# Hex Target (hex)
# 3) Use mergearmhex script to merge hex data for elf files (recipe $(HEX_TARGET) in spar/makefile)
#
################################################################################
# automatically generate dependency rules
MAKE_DEP_FILE = $(XCC) $(C_FLAGS) $(LIST_OPTIONS) -MM -MP -MF $(@:$(suffix $@)=.d) $<


# The assembly listing generated goes to stdout. Redirect to file.
REDIRECT_OUTPUT = > $(@:$(suffix $@)=.s)

ifeq ($(HOST_OS),Win32)
REDIRECT_ASM_OUTPUT = > NUL
else
REDIRECT_ASM_OUTPUT = > /dev/null
endif

.INTERMEDIATE: $(SPAR_SETUP_CALL_CGS)


# The list file is really a side effect of building the elf
$(ELF_OUT_LIST): $(ELF_OUT)


$(SPAR_SETUP_CALL_CGS): $(ELF_OUT)
	$(QUIET)-$(XMD) $(@D)
	$(QUIET)$(PERL) $(SETUP_CALL_SCRIPT) $(ELF_OUT) $(READ_ELF) $(SPAR_CRT_SETUP)


# elf -> hex, in case missing; covering tier1, tier2, and any SPARs
%.hex: %.elf
	$(QUIET)-$(XMD) $(@D)
	$(QUIET)$(HEXCOPY) -O ihex $< $@


ELF_OUT_BIN = $(ELF_OUT).bin

ifeq ($(DIRECT_LOAD),y)
  ENTRY = 'DIRECT_LOAD'
else
  ENTRY = 'ENTRY \"Data\"'
endif

# From spar.elf, make spar.elf.SECTION.cgs, or a comment only if empty.
$(ELF_OUT)%.cgs: $(ELF_OUT)
	$(QUIET)-$(XMD) $(@D)
	$(eval VERBOSE_TRACE = $(if $(findstring 1,$(VERBOSE)),-v 1,))
	$(QUIET)$(PERL) $(SECTION_TO_CGS) -e $< -o $(OBJDUMP) -s $* $(VERBOSE_TRACE) > $@

# From spar.elf, make spar.elf.SECTION.ccgs, or a comment only if empty
$(ELF_OUT)%.ccgs: $(ELF_OUT)
	$(QUIET)-$(XMD) $(@D)
	$(eval VERBOSE_TRACE = $(if $(findstring 1,$(VERBOSE)),-v 1,))
	$(QUIET)$(PERL) $(SECTION_TO_CGS) -e $< -o $(OBJDUMP) -s $* -c $(COMPRESSOR) $(VERBOSE_TRACE)  > $@

# From spar.elf.xyz.hex, make spar.elf.SECTION.cgs, or a comment only if empty
$(ELF_OUT)%.ocgs: $(ELF_OUT)
	$(QUIET)-$(XMD) $(@D)
	$(eval VERBOSE_TRACE = $(if $(findstring 1,$(VERBOSE)),-v 1,))
	$(QUIET)$(PERL) $(SECTION_TO_CGS) -e $< -o $(OBJDUMP) -s $* -i $(word 2,$(subst _, ,$*)) $(VERBOSE_TRACE) > $@

# If we have overlays enabled, we need to place them somewhere. Autogenerate this scatter file.
OVERLAY_SCAT = $(BIN_OUT_DIR)/spar_ram_overlays.ld

# Make sure that the overlaid objects are always in a known order. All the autogenerated code
# depends on the order being known at compile time. So, sort the overlaid sources into objs.
# We don't quite care what order, as long as it is deterministic.
OVERLAY_OBJS = $(addsuffix .o,$(sort $(basename $(OVERLAY_SRC))))

# Generate trampoline functions for each exported function in the overlaid object file.
#   - Get all the exported function names in the object file using NM
#   - Append --wrap <function> for each function to wrap_flags.inc
#   - Invoke $(GEN_OVERLAY_FILES) and generate trampoline functions for each function in the object.
ifneq ($(OVERLAY_SRC),)
$(BIN_OUT_DIR)/trampoline_%.s: $(BIN_OUT_DIR)/%.o
	$(eval FUNCTIONS = $(call QUIET_SHELL, $(call PERL_FIX_QUOTES,$(PERL) -e 'open(FL, "$(NM) --defined-only -s -g $(subst /,\,$<) |");while(<FL>){chomp $$_;if($$_=~/[a-fA-F0-9]+\s+T\s+(.*)/){print " ".$$1;}}close(FL);')))
	$(QUIET)$(ECHO) "Generating trampoline functions for overlaid area $*...";
	$(QUIET)$(PERL) $(PRINT_WRAP_FLAGS) $(FUNCTIONS) >> $(BIN_OUT_DIR)/wrap_flags.inc
	$(QUIET)$(PERL) $(GEN_OVERLAY_FILES) -gen=tramp -tc=gcc -file=$< $(FUNCTIONS) > $@

# Add the trampoline function objects to files to be linked.
OBJS += $(addsuffix .o, $(addprefix $(BIN_OUT_DIR)/trampoline_, $(sort $(basename $(OVERLAY_SRC)))))

# Get the linker to pick up symbols to be wrapped from wrap_flags.inc
EXTRA_LD_FLAGS += @$(BIN_OUT_DIR)/wrap_flags.inc
endif

# If overlays are enabled, invoke $(GEN_OVERLAY_FILES) and generate execution regions in
# the main scatter file for each overlaid object file.
ifneq ($(OVERLAY_SRC),)
$(OVERLAY_SCAT): $(OBJS)
	$(QUIET)$(PERL) $(GEN_OVERLAY_FILES) -gen=scat -tc=gcc -dir=$(dir $(ELF_OUT)) $(OVERLAY_OBJS) > $@
else
$(OVERLAY_SCAT): $(OBJS)
	$(QUIET)$(ECHO)   > $@
endif

# Always autogenerate the library installers
OBJS += $(BIN_OUT_DIR)/lib_installer.o

$(BIN_OUT_DIR)/lib_installer.c: $(LIBS) $(filter-out $(BIN_OUT_DIR)/lib_installer.o,$(OBJS))
	$(eval VERBOSE_TRACE = $(if $(findstring 1,$(VERBOSE)),-v=1,))
	$(QUIET)$(PERL) $(GEN_LIB_INSTALLER) $(VERBOSE_TRACE) -tc=gcc -tool=$(FROMELF) $^ > $@

# Force pre-processing the scatter-loader file - Getting linker to do this
# instead does not always work in Cygwin. Needs to be generated everytime before link
# The memory loacations are calculated from the base elf.
$(SPAR_LINK_LOAD_FILE): $(TC)/spar_$(SPAR_IN).ld $(ELF_LIST) $(OBJS) $(ELF_LIST:.elf=.lst) $(OVERLAY_SCAT) FORCE
	$(eval IRAM_BEGIN  ?= $(call QUIET_SHELL, $(IRAM_BEGIN_CMD)))
	$(eval IRAM_LEN ?= $(call QUIET_SHELL, $(IRAM_LEN_CMD)))
	$(eval IROM_BEGIN  ?= $(call QUIET_SHELL, $(IROM_BEGIN_CMD)))
	$(eval IROM_LEN    ?= $(call QUIET_SHELL, $(IROM_LEN_CMD)))
	$(eval LINK_LOC_FLAGS += IRAM_BEGIN=$(IRAM_BEGIN) IRAM_LEN=$(IRAM_LEN) IROM_BEGIN=$(IROM_BEGIN) IROM_LEN=$(IROM_LEN) )
	$(QUIET)$(XCC) -E -x c -P $(addprefix -D,$(LINK_LOC_FLAGS)) -I $(dir $(ELF_OUT)) -o $@ $<

.FORCE:


.PHONY: print_stats
print_stats: $(SPAR_CGS_TARGET)
	$(QUIET)$(PERL) $(PRINT_STATS)  $(ELF_OUT_LIST)  $(ELF_LIST)
